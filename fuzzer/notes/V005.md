# Dataflow Coverage Tracking

## Overview

The dataflow coverage system tracks which intermediate locations in taint flows are executed during program runtime. This enables fuzzing campaigns to measure how well they explore the taint propagation paths.

## Architecture

```
┌─────────────┐
│ SARIF File  │  (Taint flows with source/sink/intermediate locations)
└──────┬──────┘
       │
       v
┌──────────────────┐
│  Orchestrator    │
│  (FlowManager)   │  1. Parse flows
│                  │  2. Assign IDs (SRC_ID, SINK_ID, INTERMEDIATE_ID)
│                  │  3. Serialize to .flowdb
└──────┬───────────┘
       │
       v
┌─────────────────────────────┐
│  program.ll.flowdb          │  (Serialized database)
│                             │
│  SOURCE,1,file.c,10,5,10    │
│  SINK,1,file.c,20,7,12      │
│  INTERMEDIATE,1,file.c,15,3,8│
│  FLOW,1,1,1,description     │
└──────┬──────────────────────┘
       │
       ├─────────────────────┐
       v                     v
┌──────────────────┐  ┌──────────────────────┐
│ DataFlowCoverage │  │  Fuzzer Service      │
│      Pass        │  │  (Future)            │
│                  │  │                      │
│  Instruments:    │  │  Maps coverage back  │
│  df_coverage_hit │  │  to taint flows      │
│  (INTERMEDIATE)  │  │                      │
└────────┬─────────┘  └──────────────────────┘
         │
         v
┌──────────────────────┐
│  program.instrumented │
│                       │
│  df_coverage_hit(1);  │  ← Before intermediate location
│  temp = data + 1;     │
│                       │
│  df_coverage_hit(2);  │
│  result = temp * 2;   │
└────────┬──────────────┘
         │
         v
┌──────────────────────┐
│ df_coverage_runtime  │
│                      │
│  Global map:         │
│  [ID] → hit_count    │
│                      │
│  Summary on exit     │
└──────────────────────┘
```

## Components

### 1. FlowManager (Orchestrator)

**File:** `orchestrator/FlowManager.{h,cpp}`

**Purpose:** 
- Central database for taint flows
- Assigns unique IDs to sources, sinks, and intermediate locations
- Deduplicates locations (same location = same ID)
- Serializes to `.flowdb` format for consumption by passes and services

**Key Methods:**
```cpp
void addFlow(const Flow &F);  // Automatically processes flow.path
int addIntermediateLocation(const SourceLocation &Loc);  // Manual add
bool serializeToFile(const std::string &FilePath);
bool deserializeFromFile(const std::string &FilePath);
```

**ID Assignment:**
- `SRC_ID`: Unique per source location
- `SINK_ID`: Unique per sink location  
- `INTERMEDIATE_ID`: Unique per intermediate location
- `FLOW_ID`: Unique per flow (SRC_ID → SINK_ID mapping)

### 2. FlowDB Format

**File Extension:** `.flowdb`

**Format:**
```
# FlowManager Serialized Database v1.0
METADATA,flows=N,sources=M,sinks=K,intermediates=P
SOURCE,id,file,line,colStart,colEnd
SINK,id,file,line,colStart,colEnd
INTERMEDIATE,id,file,line,colStart,colEnd
FLOW,flowID,srcID,sinkID,description
```

**Example:**
```
# FlowManager Serialized Database v1.0
METADATA,flows=1,sources=1,sinks=1,intermediates=2
SOURCE,1,/workspaces/fuzzer/sense/demo/flow.c,10,15,20
SINK,1,/workspaces/fuzzer/sense/demo/flow.c,30,7,12
INTERMEDIATE,1,/workspaces/fuzzer/sense/demo/flow.c,15,10,15
INTERMEDIATE,2,/workspaces/fuzzer/sense/demo/flow.c,20,5,18
FLOW,1,1,1,Taint from source() to sink()
```

### 3. DataFlowCoveragePass

**File:** `passes/DataFlowCoveragePass.cpp`

**Purpose:** 
- Instrument intermediate locations to track coverage
- Uses MODULE pass for global initialization
- Reads `.flowdb` to get INTERMEDIATE locations and IDs

**Usage:**
```bash
opt -load-pass-plugin=./DataFlowCoveragePass.so \
    -passes=df-coverage \
    -df-flow-db=program.ll.flowdb \
    input.ll -S -o output.ll
```

**Instrumentation:**
- Inserts `df_coverage_hit(loc_id)` before each intermediate location
- Matches locations using debug info (line:col)
- Declares global `__df_coverage_map_size` for runtime allocation

### 4. df_coverage_runtime

**Files:** `runtime/df_coverage_runtime.{h,c}`

**Purpose:** 
- Global coverage map: `uint8_t __df_coverage_map[size]`
- Track hit counts for each intermediate location
- Auto-print summary on program exit

**API:**
```c
void df_coverage_init(void);              // Initialize map
void df_coverage_hit(uint32_t loc_id);    // Record hit
//void df_coverage_print_summary(void);     // Print stats
//uint8_t df_coverage_get_count(uint32_t loc_id);  // Query
//void df_coverage_reset(void);             // Reset map
__attribute__((destructor)) static void df_coverage_exit_handler(void)     // Cleanup
```

## Workflow

### Orchestrator Phase

1. **Parse SARIF:** Extract taint flows with paths
2. **Add Flows:** Call `FlowManager::addFlow(flow)`
   - Automatically assigns IDs to source, sink, and intermediate locations
   - Deduplicates identical locations
3. **Serialize:** Call `serializeToFile("program.ll.flowdb")`
4. **Generate Commands:** Create instrumentation pipeline including DataFlowCoveragePass

### Compilation Phase

1. **Compile to IR:** `clang -g -S -emit-llvm source.c -o program.ll`
2. **Instrument Sources:** `opt -passes=sample-flow-src ...`
3. **Instrument Sinks:** `opt -passes=sample-flow-sink ...`
4. **Instrument Coverage:** `opt -passes=df-coverage -df-flow-db=program.ll.flowdb ...`
5. **Link Runtime:** `clang program.instrumented.ll libdf_coverage_runtime.a -o program`

### Runtime Phase

1. **Initialize:** Coverage map allocated on first `df_coverage_hit()` call
2. **Execute:** Each intermediate location increments its counter
3. **Summary:** Destructor prints coverage statistics on exit
