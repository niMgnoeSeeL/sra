# OpenSSL x509 + gllvm/gclang IR pipeline + AFL++ + DynamoRIO — Gotchas

This doc summarizes the pitfalls we hit when fuzzing OpenSSL’s `fuzz/x509` harness written in **persistent mode** with a **bitcode-first pipeline** (gclang/gllvm → `.bc/.ll` → custom instrumentation → recompile with `afl-cc`) and when running the target under **DynamoRIO**.

---

## 1) Persistent fuzz harness: `__AFL_LOOP()` is a AFL compiler injected symbol

**Symptom:** `gclang` / `clang` complains about `__AFL_LOOP(10000)` during compilation.

**Root cause:** `__AFL_LOOP` is provided by AFL’s compiler wrapper (e.g., `afl-clang-fast`). If you compile the harness TU without that wrapper, the macro isn’t defined.

**Takeaway:** If you plan to build the harness with non-AFL compilers (e.g., gllvm/gclang) you must handle the missing macro somehow (either by adjusting the build mode or by providing compatible definitions).

**FIX**:
We added a stub definition of `__AFL_LOOP` to the harness. It expands to a simple loop `__afl_persistent_loop` that runs once when the compiler is not `afl-cc`, so that the harness can compile and be instrumented. It is marked as a weak definition, so that if the compiler is `afl-cc` it will be overwritten by the real definition. 
```c
#ifndef __AFL_LOOP

/* Make afl-fuzz auto-detect persistent mode even when we didn't compile
 * this file with afl-clang-fast (e.g., gclang/gllvm -> bitcode pipeline). */
// See
// https://groups.google.com/g/afl-users/c/GYx4gTcPAtU
// Or use the flag __AFL_PERSISTENT=1
__attribute__((used)) static volatile char __afl_persistent_sig[] =
    "##SIG_AFL_PERSISTENT##";

#if defined(__APPLE__)
__attribute__((weak)) extern int
__afl_persistent_loop(unsigned int max_cnt) __asm__("___afl_persistent_loop");
#else
__attribute__((weak)) extern int
__afl_persistent_loop(unsigned int max_cnt) __asm__("__afl_persistent_loop");
#endif

__attribute__((weak)) int __afl_persistent_loop(unsigned int max_cnt) {
  (void)max_cnt;
  static int first = 1;
  if (first) {
    first = 0;
    return 1;
  } /* outside AFL: run once */
  return 0;
}

// map the macro to the link-time hook
#define __AFL_LOOP(N) __afl_persistent_loop((unsigned int)(N))
#endif
```

---

## 2) Persistent mode must be *detected* by `afl-fuzz` (marker string matters)

**Symptom:** Forkserver comes up, but AFL “hangs”/times out during the very first calibration stage (stage 1/7), often triggered by the first seed.

**Root cause:** In persistent mode, the target uses pause/resume semantics between iterations. If `afl-fuzz` does not recognize the target as persistent, it may fail to drive the iteration protocol correctly, causing apparent hangs/timeouts.

**Fix that worked (bitcode-first pipeline):** Embed the signature string so `afl-fuzz` auto-detects persistent mode even when the harness wasn’t compiled directly with `afl-clang-fast`:

```c
/* Make afl-fuzz auto-detect persistent mode even when we didn't compile
 * this TU with afl-clang-fast (e.g., gclang/gllvm -> bitcode pipeline). */
__attribute__((used))
static volatile char __afl_persistent_sig[] = "##SIG_AFL_PERSISTENT##";
```
---

## 3) Don’t run a persistent-mode binary “standalone” with a pipe (it will stop)

**Symptom:**

```bash
cat seed | ./harness_afl
# or
cat seed | drrun -- ./harness_afl
```

…prints `Stopped` and the pipeline freezes.

**Root cause:** Persistent mode make the instrumented target issues a `SIGSTOP` to pause itself between iterations and transfer control back to `afl-fuzz`, which under persistent mode will issue `SIGCONT` to resume the target for the next iteration. When you run the persistent target standalone (not under `afl-fuzz`), there is no fuzzer to issue the `SIGCONT`, so the target remains stopped indefinitely.

**Fix:** If you want persistent behavior, run it **under `afl-fuzz`**. If you want standalone runs, build a one-shot/non-persistent variant.

---

## 4) `drrun` in front of the target breaks AFL’s “is it instrumented?” check

**Symptom:** AFL aborts with:

* “Looks like the target binary is not instrumented!”

**Root cause:** When you run:

```bash
afl-fuzz ... -- drrun -- ./target
```

AFL’s binary checks inspect **`drrun`**, not your target.

**Fix:** Use:

```bash
export AFL_SKIP_BIN_CHECK=1
```

---

## 5) Map-size negotiation can fail through a wrapper (`FS_ERROR_MAP_SIZE`)

**Symptom:** AFL aborts with an error complaining that `AFL_MAP_SIZE` is not set / required size is large, often showing `FS_ERROR_MAP_SIZE`.

**Root cause:** AFL++ may need to “reinit” the coverage map size after counting edges. Through wrappers like `drrun`, the negotiation can be brittle.

**Fix:** Pre-set `AFL_MAP_SIZE` to the value the target reports (from AFL debug output):

```bash
MAP_SIZE=$(AFL_DUMP_MAP_SIZE=1 "$DYNAMORIO_HOME/bin64/drrun" -thread_private -- /path/to/harness)
export AFL_MAP_SIZE=$MAP_SIZE
```
---

## 6) DynamoRIO + AFL is slow (calibration can look “stuck” even when correct)

**Symptom:** Calibration stage progress appears to stall, especially under `drrun` and/or with heavy clients.

**Reality:** Calibration runs seeds multiple times; DynamoRIO adds significant overhead, so this can be *legitimately* slow.

**How to tell if it’s actually working:** Watch AFL stats:

```bash
watch -n 1 "grep -E 'execs_done|execs_per_sec|cycles_done|cur_path' $OUT/default/fuzzer_stats"
```

If `execs_done` increases, it’s running.

---

## Known-good command template: AFL++ + DynamoRIO + persistent stdin harness

```bash
export AFL_SKIP_BIN_CHECK=1
export AFL_MAP_SIZE=<printed_value>
# Optional: helps if persistent detection is bypassed by wrapper / skip-check
export __AFL_PERSISTENT=1

/workspaces/fuzzer/AFLplusplus/afl-fuzz \
  -i "$CORPUS" -o "$OUT" \
  -t 1000000+ \
  -- \
  "$DYNAMORIO_HOME/bin64/drrun" -thread_private -- "$BIN"
```

(Adjust `-thread_private` and `-t` based on your DR overhead.)
