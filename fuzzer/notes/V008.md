# PointeeBaseRecovery: MemorySSA-based Pointer Tracing

## Problem

`getUnderlyingObjects()` is insufficient for tracking pointers through memory:
- **Stops at LoadInst** - returns the load itself as a "base"
- **Breaks flow analysis** - can't detect when call arguments are loaded from tracked allocations

Example failure:
```llvm
%base = alloca [4096 x i8]        ; Target allocation we're tracking
store ptr %base, ptr %ptr_var     ; Store pointer to variable
%loaded = load ptr, ptr %ptr_var  ; Load it back
call @sink(ptr %loaded)           ; Pass to function

getUnderlyingObjects(%loaded) → {%loaded}  ❌ Wrong!
Need: {%base}  ✅
```

## Solution: MemorySSA + Alias Analysis

Use **MemorySSA** to trace loads through their defining stores, extracting the stored SSA values.

### Key Components

**PointeeBaseRecoverer** (`PointeeBaseRecovery.{h,cpp}`):
- Strips GEPs/casts, splits phi/select nodes
- **When hitting LoadInst**: uses MemorySSA to find defining stores
- **Filters false dependencies**: uses alias analysis to skip unrelated stores
- **Handles MemoryPhi**: explores control flow merges with fanout limits

**Configuration** (`PointeeRecoveryConfig`):
- `MaxDepth` - recursion limit (default: 16)
- `MaxMemPhiFanout` - MemoryPhi exploration limit (default: 64)
- `VerboseDebug` - debug output flag

## Implementation

### Usage Pattern
```cpp
auto &AA = FAM.getResult<AAManager>(F);
auto &MSSA = FAM.getResult<MemorySSAAnalysis>(F).getMSSA();
MSSA.ensureOptimizedUses();  // Critical! Enables AA-optimized MemorySSA

PointeeRecoveryConfig Config(16, 64, false);
PointeeBaseRecoverer Recoverer(F, AA, MSSA, Config);

SmallPtrSet<const Value *, 16> Bases;
Recoverer.recoverBases(PointerValue, CtxInst, Bases);
```

### Algorithm
1. Strip pointer casts/GEPs (follow SSA edges)
2. Split phi/select nodes (explore all values)
3. **On LoadInst**:
   - Get MemoryUse for the load
   - Find defining MemoryDef via `getOptimized()` (AA-filtered)
   - If StoreInst: extract stored value, recurse
   - If MemoryPhi: explore incoming values
   - If LiveOnEntry: trace load's pointer operand (handles globals)
4. Stop at base objects:
   - `AllocaInst` - stack allocations
   - `GlobalValue` - global variables, functions
   - `Argument` - function parameters
   - `CallBase` - function returns (malloc, custom allocators, etc.)

## Critical Gotchas

### 1. **Must Call `ensureOptimizedUses()`**
Without this, MemorySSA is **conservative** - doesn't use alias analysis.

Example (without optimization):
```llvm
%1 = alloca ptr      ; Different allocas
%3 = alloca i64      ; 
store i64 %x, ptr %3         ; MemoryDef(8) - unrelated store
%loaded = load ptr, ptr %1   ; MemoryUse(8) ← Wrong! Says use=8
```

After `MSSA.ensureOptimizedUses()`:
```llvm
%loaded = load ptr, ptr %1   ; MemoryUse(7) ← Correct! Skips def(8)
```

### 2. **Alias Analysis Check is Still Needed**
Even with optimized MemorySSA, need manual AA check in `recoverFromMemoryDef()`:
```cpp
auto AR = AA.alias(MemoryLocation::get(SI), MemoryLocation::get(OrigLoad));
if (AR == AliasResult::NoAlias) {
  // Skip this store, continue up the chain
  recoverFromMemoryDef(Def->getDefiningAccess(), OrigLoad, ...);
  return;
}
```

**Why?** `optnone` disables optimizations → worse alias analysis → conservative MemorySSA even with `ensureOptimizedUses()`.

### 3. **Use `getOptimized()` not `getDefiningAccess()`**
```cpp
// Wrong:
MemoryAccess *DefAcc = Use->getDefiningAccess();  ❌

// Right:
MemoryAccess *DefAcc = Use->getOptimized() ? Use->getOptimized() 
                                            : Use->getDefiningAccess();  ✅
```

### 4. **MemorySSA is Conservative by Design**
- Soundness over precision (never miss a dependency)
- Without optimizations (SROA, Mem2Reg), can't prove stack allocas are disjoint
- Solution: Runtime AA check filters false positives

## Analysis Passes (Not Transformations)

No transformation passes improve MemorySSA precision without modifying IR:
- `globals-aa`, `scev-aa`, `tbaa` - already included in `AAManager`
- `mem2reg`, `sroa` - would help but are **transformations**

**Best practice for analysis-only**: Use `ensureOptimizedUses()` + manual AA checks.

## Files

- `passes/PointeeBaseRecovery.h` - Interface (`PointeeRecoveryConfig`, `PointeeBaseRecoverer`)
- `passes/PointeeBaseRecovery.cpp` - Implementation
- `passes/PointeeRecoveryPass.cpp` - Demo pass showing usage

## Testing

```bash
# Without optnone (optimal):
opt-20 -load-pass-plugin=./PointeeRecoveryPass.so \
       -passes=recover-pointee-bases \
       --recover-pointee-only-calls-to=fgets \
       input.ll -S -o /dev/null

# Expected: Directly finds base allocations, minimal AA filtering
```

### Test Cases Verified

1. **Stack allocation** (`alloca`):
   ```llvm
   %buf = alloca [4096 x i8]
   %ptr = getelementptr %buf, 0, %idx
   call @fgets(ptr %ptr, ...)
   → Recovers: %buf = alloca [4096 x i8]
   ```

2. **Global variable** (direct and via load):
   ```llvm
   call @fgets(..., ptr @stdin, ...)
   → Recovers: @stdin = external global ptr
   ```

3. **Dynamic allocation** (`malloc`):
   ```llvm
   %buf = call ptr @malloc(i64 100)
   %ptr = getelementptr %buf, i64 10
   call @strcpy(ptr %ptr, ...)
   → Recovers: %buf = call ptr @malloc(i64 100)
   ```

4. **Function return values**:
   ```llvm
   %ptr = call ptr @custom_allocator()
   → Recovers: %ptr = call ptr @custom_allocator()
   ```

