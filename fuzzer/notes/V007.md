## Taint-Flow related CodeQL queries:

In the official CodeQL query packs for C/C++, there are several queries that focus on identifying potential security vulnerabilities related to taint flows. Taint flows occur when untrusted or *user-controlled data* is used in a way that could lead to security issues, such as buffer overflows, authentication bypasses.

```
  "CWE-020/IRUntrustedDataToExternalAPI.ql"
  "CWE-020/UntrustedDataToExternalAPI.ql"
  "CWE-022/TaintedPath.ql"
  "CWE-078/ExecTainted.ql"
  "CWE-079/CgiXss.ql"
  "CWE-089/SqlTainted.ql"
  "CWE-114/UncontrolledProcessOperation.ql"
  "CWE-120/UnboundedWrite.ql"
  "CWE-129/ImproperArrayIndexValidation.ql"
  "CWE-134/UncontrolledFormatString.ql"
  "CWE-190/ArithmeticTainted.ql"
  "CWE-190/ArithmeticUncontrolled.ql"
  "CWE-190/TaintedAllocationSize.ql"
  "CWE-290/AuthenticationBypass.ql"
  "CWE-311/CleartextBufferWrite.ql"
  "CWE-311/CleartextFileWrite.ql"
  "CWE-311/CleartextTransmission.ql"
  "CWE-313/CleartextSqliteDatabase.ql"
  "CWE-497/ExposedSystemData.ql"
  "CWE-497/PotentiallyExposedSystemData.ql"
  "CWE-611/XXE.ql"
  "CWE-807/TaintedCondition.ql"
```

#### How are they obtained:
CodeQL queries have metadata that classifies them according to the types of vulnerabilities they detect. `problem` is a pure warning. `path-problem` indicates that the query tracks a taint flow from a source (e.g., user input) to a sink (e.g., sensitive operation). *Importantly, not all `path-problem` queries are related to taint flows.*
```
@kind: problem
or 
@kind: path-problem
```
I included all the `@kind:path-problem` queries from the C/C++ Security query pack, and then manually verified that they are indeed related to taint flows. Some are filtered out despite being `path-problem`. Example exclusions:

- CWE-119/OverrunWriteProductFlow.ql: It tracks buffer overflows. Source is a buffer allocation (e.g. `char* p = new char[size]`), sink is an access that may exceed the allocation size). It doesn't care about whether the `size` is user-controlled or not.
- CWE-193/InvalidPointerDeref.ql: Similar to the above.
- CWE-319/UseOfHttp.ql: This query scans for the use of HTTP instead of HTTPS. It is not related to taint flows. Source is String containing `http://`, sink is any use of that string as a URL.


### Notes:
- CWE-020/IRUntrustedDataToExternalAPI.ql, CWE-020/UntrustedDataToExternalAPI.ql
    - These queries identify instances where untrusted data is passed to external APIs. The problem is that it captures all external API calls, e.g., an untrusted string passed to `printf`, which may lead to many false positives. So I'm leaning towards not using these two queries at all.
- CWE-078/ExecTainted.ql
    - This is the classic OS Command Injection vulnerability and you may think this will flag many issues. However, the sinks this query tracks are only commands that will run shell, e.g., `system`, `popen`, `execv`, `execl`, etc. They are defined in `predicate shellCommand` in `CommandExecution.qll`. In openssl, there are no such sinks at all.
    - Also this query only works if the *user-controlled data* has seen some concatenation before reaching the sink. Directly passing user input to `system` will not be flagged.
    - Also this query only tracks data that flows into the command string as arguments, not the command name itself. So `system(user_input)` is not flagged, but `system("ls " + user_input)` is flagged.
- CWE-190/ArithmeticTainted.ql, CWE-190/ArithmeticUncontrolled.ql
    - These 2 queries are very similar. `ArithmeticTainted` finds *user-controlled* data being used in arithmetic expression, while `ArithmeticUncontrolled` finds *uncontrolled* data (e.g. random integers) being used in arithmetic expression. The second one less common.
- CWE-190/TaintedAllocationSize.ql
    - When memory allocation size is a user-controlled data.
- CWE-290/AuthenticationBypass.ql
    - This query finds cases where user-controlled data is used in authentication of some identity.




