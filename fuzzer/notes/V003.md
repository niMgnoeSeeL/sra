# SampleFlowSrcPass: Taint Source Instrumentation

## Goal

The `SampleFlowSrcPass` is an LLVM instrumentation pass that inserts **type-aware sampling calls** at taint source locations identified by static analysis. The goal is to enable **snapshot fuzzing of the taint flow** by allowing the fuzzer to directly sample/mutate the secret (tainted variable), facilitating downstream analysis of taint risk.

### Key Concepts

1. **Taint Source**: A program location where untrusted/external data enters the program
   - Examples: `fgets()`, `read()`, user input, network packets

2. **Type-Aware Sampling**: Different sampling strategies based on the tainted data type:
   - **Scalars** (int, double): Load → Sample → Store pattern
   - **Arrays/Buffers**: Direct memory mutation via `sample_bytes()`
   - **Struct Fields**: Field-sensitive sampling (only the tainted field)

3. **Field/Dimension Sensitivity**: 
   - For `struct.field`, only sample the field, not the entire struct
   - For `matrix[i]`, assuming `char matrix[rows][cols][...]` only sample that row `i`, not the entire multi-dimensional array

---

## Implementation

### Overview

The pass operates in two modes:


1. **Line:Column Mode** (recommended for better precision):
   - Input: `-sample-line=<line> -sample-col-start=<col> -sample-col-end=<col>`
   - Matches instructions by source location
   - Works for: `struct.field`, `array[index]`, complex expressions
2. **Variable Name Mode** (fallback for simple expressions):
   - Input: `-sample-var-name=<name> -sample-line=<line>`
   - Uses `DILocalVariable` debug metadata to find the variable
   - Works for: `int x`, `char buf[16]`, etc.
   - Note: This mode is less precise and so do not use it for complex expressions, e.g., (`student.age.year`).

### Algorithm

1.  **Locate the variable**:
    -   a) Variable name mode: Search for DILocalVariable matching the name.
        This is unrecommended due to potential shadowing and aliasing.
        It finds the BASE addresses of tainted definition conservatively.
    -   b) Line:col mode: Find instruction at the specified source location.
        (Recommended) Directly maps to the addressed that is tainted.
        This is more precise, e.g., for array/struct accesses.
    This step produces a BASE address and an ANCHOR instruction.

2.  **Build statement slice**: Collect all instructions on the same source
    line and lexical scope as the ANCHOR as a slice.

3.  **Find last writer**: Within the statement slice, find the last writer to
    the BASE address (using alias analysis, TODO: add MemorySSA). This is the safe insertion point for the sampling call.

4.  **Insert sampling call**:
    -   For scalars: Load → Sample → Store (replaces value in-place)
    -   For buffers: sample_bytes(ptr, size) after the taint source
    -   TODO: For structs: need to implement a sample_struct(ptr, Type)
        function in the runtime

### Type Inference via GEP Analysis

```cpp
// For: %ptr = getelementptr %Type, ptr %base, indices...

if (SourceType->isArrayTy()) {
  // Arrays: Conservative - return whole array
  // Example: char buf[16]; &buf[5] → taint entire buf[16]
  return SourceType;  // [16 x i8]
}

if (SourceType->isStructTy()) {
  // Structs: Field-sensitive - return only the field
  // Example: struct S s; &s.age → taint only s.age
  Type *FieldType = SourceType->getStructElementType(FieldIndex);
  return FieldType;  // i32 (not entire struct)
}
```

### Example Transformations

#### 1. Scalar (int)
```c
int x;
read(STDIN_FILENO, &x, sizeof(x));  // line 8
```

**Before:**
```llvm
%x = alloca i32
%call = call i64 @read(i32 0, ptr %x, i64 4)
```

**After:**
```llvm
%x = alloca i32
%call = call i64 @read(i32 0, ptr %x, i64 4)
%1 = load i32, ptr %x              ; Load tainted value
%2 = call i32 @sample_int(i32 %1)  ; Sample it
store i32 %2, ptr %x                ; Store back
```

#### 2. Byte Array
```c
char buf[16];
fgets(buf, 16, stdin);
```

**Before:**
```llvm
%buf = alloca [16 x i8] ; line1
%ptr = getelementptr [16 x i8], ptr %buf, i64 0, i64 0 ; <-- Anchor: line 2, implicit type cast from [16 x i8]* to i8* at buf
%call = call ptr @fgets(ptr %ptr, i32 16, ptr %stdin) ; line 2
```

**After:**
```llvm
%buf = alloca [16 x i8]
%ptr = getelementptr [16 x i8], ptr %buf, i64 0, i64 0
%call = call ptr @fgets(ptr %ptr, i32 16, ptr %stdin)
call void @sample_bytes(ptr %ptr, i32 16)  ; Sample entire buffer, because the tainted variable is a i8* obtained from a GEP from [16 x i8]
```

#### 3. Struct Field (Field-Sensitive)
```c
struct Student { int id; int age; char name[32]; };
struct Student s;
read(STDIN_FILENO, &s.age, sizeof(s.age)); 
```

**Before:**
```llvm
%s = alloca %struct.Student        ; 40 bytes total
%age_ptr = getelementptr %struct.Student, ptr %s, i32 0, i32 1 ; <-- Anchor: line 3, points to &s.age, %age_ptr is of type i32*
%call = call i64 @read(i32 0, ptr %age_ptr, i64 4)
```

**After:**
```llvm
%s = alloca %struct.Student
%age_ptr = getelementptr %struct.Student, ptr %s, i32 0, i32 1
%call = call i64 @read(i32 0, ptr %age_ptr, i64 4)
%1 = load i32, ptr %age_ptr        ; Load only the age field
%2 = call i32 @sample_int(i32 %1)  ; Sample only 4 bytes (int)
store i32 %2, ptr %age_ptr          ; Store back to age field
```

**Key**: Samples only 4 bytes (the `age` field), not 40 bytes (entire struct)!

#### 4. Multi-Dimensional Array (Dimension-Sensitive)
```c
char matrix[4][16];  // 4 rows × 16 columns = 64 bytes
read(STDIN_FILENO, matrix[1], 16);  // line 8
```

**Before:**
```llvm
; here we assume that code generated with -O0 perform GEP, one-indexing at a time. If the two GEPs are merged, then we would have guessed a PointedType of [4 x [16 x i8]], i.e., entire matrix
%matrix = alloca [4 x [16 x i8]]                          ; 64 bytes
%row1 = getelementptr [4 x [16 x i8]], ptr %matrix, i64 0, i64 1
%ptr = getelementptr [16 x i8], ptr %row1, i64 0, i64 0
%call = call i64 @read(i32 0, ptr %ptr, i64 16)
```

**After:**
```llvm
%matrix = alloca [4 x [16 x i8]]
%row1 = getelementptr [4 x [16 x i8]], ptr %matrix, i64 0, i64 1
%ptr = getelementptr [16 x i8], ptr %row1, i64 0, i64 0
%call = call i64 @read(i32 0, ptr %ptr, i64 16)
call void @sample_bytes(ptr %ptr, i32 16)  ; Sample only 16 bytes (one row)
```

**Key**: Samples only 16 bytes (one row), not 64 bytes (entire matrix)!

The pass analyzes the chained GEPs and infers that `ptr` points to `[16 x i8]`, not `[4 x [16 x i8]]`.

---

## Implementation Details

### Scope Validation
When using variable name mode, the pass validates that:
1. The variable's declaration scope contains the taint line
2. Handles variable shadowing in nested scopes correctly

```cpp
// Check if taint line is within variable's scope
DIScope *VarScope = DIVar->getScope();
unsigned VarLine = DIVar->getLine();
if (TaintLine < VarLine || !isInScope(VarScope, TaintLine)) {
  continue;  // Wrong scope
}
```

### Finding the Last Instruction
Complex expressions like `matrix[1][0]` may generate multiple instructions with the same debug location:
```llvm
%3 = getelementptr ..., !dbg !28  ; matrix[1]
%4 = getelementptr ..., !dbg !28  ; matrix[1][0]  ← Use this one
```

The pass finds the **last** instruction matching line:col to get the most specific pointer. This gives us the best chance to find the **closest type** that is the most precised one, being defined with taint.

### Safe Insertion Point
The pass identifies the "last writer" in the statement slice:
- For calls: The call instruction itself (if it modifies the variable)
- For stores: The store instruction
- Uses alias analysis to verify memory effects

Sampling is inserted **immediately after** the last writer using `CallInst::insertAfter()` for precise placement.

---

## Usage

### Mode Selection
- **Simple variables**: Use variable name mode
  ```bash
  -sample-var-name=buf -sample-line=7
  ```

- **Field accesses / Array elements**: Use line:col mode
  ```bash
  -sample-line=14 -sample-col-start=22 -sample-col-end=28
  ```

### Compilation Requirements
- Debug info: `-g`
- Disable optnone (for line:col mode): `-Xclang -disable-O0-optnone`
- LLVM 20+ (for new debug record format support)

### Example Commands

```bash
# Compile to IR
clang-20 -O0 -g -S -emit-llvm -Xclang -disable-O0-optnone \
  program.c -o program.ll

# Run the pass (variable name mode)
opt-20 -load-pass-plugin=./SampleFlowSrcPass.so \
  -passes='function(sample-flow-src)' \
  -sample-var-name=buf -sample-line=7 \
  -S program.ll -o program_sampled.ll

# Run the pass (line:col mode)
opt-20 -load-pass-plugin=./SampleFlowSrcPass.so \
  -passes='function(sample-flow-src)' \
  -sample-line=14 -sample-col-start=22 -sample-col-end=28 \
  -S program.ll -o program_sampled.ll
```

---

## Testing

Test coverage includes:
1. **Byte arrays**: `test_taint_src_insert_sample_byte_array.sh`
2. **Struct fields**: `test_taint_src_insert_sample_struct.sh`
3. **Multi-dimensional arrays**: `test_taint_src_insert_sample_mdarray.sh`
4. **Scalar types**: `test_taint_src_insert_sample_scalar.sh`

All tests verify:
- Correct sampling function is used (sample_int/sample_double/sample_bytes)
- Correct size is computed
- Insertion point is correct (after the taint source)

---

## Future Work

- Support for additional scalar types (i8, i16, i64, float)
- Global variable support via `DIGlobalVariableExpression`
- Batch instrumentation from SARIF taint analysis results
