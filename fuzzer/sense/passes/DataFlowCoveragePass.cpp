/**
 *===----------------------------------------------------------------------===//
 * DataFlowCoveragePass: Track Intermediate Dataflow Locations
 *===----------------------------------------------------------------------===//
 *
 *  Overview:
 *  ----------
 *  This pass instruments intermediate locations in taint flows to track
 *  dataflow coverage. It uses a global coverage map (similar to AFL's edge
 *  coverage) where each intermediate location increments its assigned index.
 *
 *  This approximates dataflow coverage using statement coverage - we track
 *  when each intermediate step in a taint path is reached during execution.
 *
 *  The pass reads the FlowManager serialized database (.flowdb) generated by
 *  the orchestrator and instruments all INTERMEDIATE locations.
 *
 *  Usage:
 *  ------
 *      opt -load-pass-plugin ./libDataFlowCoveragePass.so \
 *          -passes=df-coverage \
 *          -df-flow-db=program.ll.flowdb \
 *          input.ll -S -o output.ll
 *
 *  Input Format (.flowdb):
 *  -----------------------
 *  Generated by FlowManager::serializeToFile()
 *  Contains INTERMEDIATE,ID,file,line,colStart,colEnd entries
 *
 *  Runtime Integration:
 *  --------------------
 *  The pass declares and calls: void df_coverage_hit(uint32_t loc_id)
 *  This function increments: df_coverage_map[loc_id]
 *
 *  Notes:
 *  ------
 *    • Requires debug info (-g) for line:col matching
 *    • Uses MODULE pass to initialize coverage map size
 *    • Coverage map is exported for fuzzer integration
 *
 *===----------------------------------------------------------------------===//
 */

#include "llvm/IR/DebugInfoMetadata.h"
#include "llvm/IR/DebugLoc.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/PassManager.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Passes/PassPlugin.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <fstream>
#include <set>
#include <sstream>
#include <string>
#include <vector>

using namespace llvm;

static cl::opt<std::string>
    FlowDbFileOpt("df-flow-db",
                  cl::desc("FlowManager serialized database file (.flowdb)"),
                  cl::init(""));

namespace {

// Represents an intermediate location to instrument
struct IntermediateLocation {
  uint32_t id;
  std::string filePath;
  unsigned line;
  unsigned colStart;
  unsigned colEnd;
};

// Represents a flow with its intermediate path
struct FlowInfo {
  uint32_t flowID;
  uint32_t srcID;
  uint32_t sinkID;
  std::vector<uint32_t> intermediateIDs;
  std::string description;
};

// Parse the FlowManager database and extract intermediate locations + flows
std::pair<std::vector<IntermediateLocation>, std::vector<FlowInfo>>
parseFlowDatabase(const std::string &FilePath) {
  std::vector<IntermediateLocation> Locations;
  std::vector<FlowInfo> Flows;

  std::ifstream File(FilePath);
  if (!File.is_open()) {
    errs() << "[df-coverage] ERROR: Could not open file: " << FilePath << "\n";
    return {Locations, Flows};
  }

  std::string Line;
  while (std::getline(File, Line)) {
    if (Line.empty() || Line[0] == '#')
      continue;

    std::istringstream ISS(Line);
    std::string Type;
    std::getline(ISS, Type, ',');

    // Parse INTERMEDIATE entries
    if (Type == "INTERMEDIATE") {
      // Parse: INTERMEDIATE,ID,file,line,colStart,colEnd
      std::string IDStr, FilePath, LineStr, ColStartStr, ColEndStr;

      if (!std::getline(ISS, IDStr, ',') || !std::getline(ISS, FilePath, ',') ||
          !std::getline(ISS, LineStr, ',') ||
          !std::getline(ISS, ColStartStr, ',') ||
          !std::getline(ISS, ColEndStr, ',')) {
        errs() << "[df-coverage] WARNING: Malformed INTERMEDIATE line: " << Line
               << "\n";
        continue;
      }

      IntermediateLocation Loc;
      Loc.id = std::stoul(IDStr);
      Loc.filePath = FilePath;
      Loc.line = std::stoul(LineStr);
      Loc.colStart = std::stoul(ColStartStr);
      Loc.colEnd = std::stoul(ColEndStr);

      Locations.push_back(Loc);
    }
    // Parse FLOW entries to get intermediate IDs per flow
    else if (Type == "FLOW") {
      // Parse: FLOW,flowID,srcID,sinkID,intermediate_ids=[...],description
      std::string FlowIDStr, SrcIDStr, SinkIDStr, IntermediateIDsStr,
          Description;

      if (!std::getline(ISS, FlowIDStr, ',') ||
          !std::getline(ISS, SrcIDStr, ',') ||
          !std::getline(ISS, SinkIDStr, ',') ||
          !std::getline(ISS, IntermediateIDsStr, ',')) {
        errs() << "[df-coverage] WARNING: Malformed FLOW line: " << Line
               << "\n";
        continue;
      }

      std::getline(ISS, Description); // Rest of line

      FlowInfo Flow;
      Flow.flowID = std::stoul(FlowIDStr);
      Flow.srcID = std::stoul(SrcIDStr);
      Flow.sinkID = std::stoul(SinkIDStr);
      Flow.description = Description;

      // Parse intermediate IDs from [1,2,3] format
      if (IntermediateIDsStr.size() >= 2 && IntermediateIDsStr.front() == '[' &&
          IntermediateIDsStr.back() == ']') {
        std::string IDsStr =
            IntermediateIDsStr.substr(1, IntermediateIDsStr.size() - 2);
        if (!IDsStr.empty()) {
          std::istringstream IDsStream(IDsStr);
          std::string IDStr;
          while (std::getline(IDsStream, IDStr, ',')) {
            Flow.intermediateIDs.push_back(std::stoul(IDStr));
          }
        }
      }

      Flows.push_back(Flow);
    }
  }

  File.close();

  errs() << "[df-coverage] Loaded " << Locations.size()
         << " intermediate locations and " << Flows.size() << " flows from "
         << FilePath << "\n";

  return {Locations, Flows};
}

// Check if debug location matches the target location
bool matchesLocation(const DebugLoc &DL, const IntermediateLocation &Loc) {
  if (!DL)
    return false;

  // Extract file path from debug info
  StringRef File = DL->getFilename();
  if (!File.ends_with(Loc.filePath) && File != Loc.filePath) {
    // Try matching just the basename
    size_t LastSlash = Loc.filePath.find_last_of('/');
    std::string BaseName = (LastSlash != std::string::npos)
                               ? Loc.filePath.substr(LastSlash + 1)
                               : Loc.filePath;
    if (!File.ends_with(BaseName))
      return false;
  }

  if (DL.getLine() != Loc.line)
    return false;

  unsigned Col = DL.getCol();
  if (Col < Loc.colStart || Col > Loc.colEnd)
    return false;

  return true;
}

struct DataFlowCoveragePass : public PassInfoMixin<DataFlowCoveragePass> {

  PreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM) {
    errs() << "=== DataFlowCoveragePass::run on module: " << M.getName()
           << " ===\n";

    if (FlowDbFileOpt.empty()) {
      errs() << "[df-coverage] No flow database specified, skipping.\n";
      return PreservedAnalyses::all();
    }

    // Parse intermediate locations and flows from FlowManager database
    auto [Locations, Flows] = parseFlowDatabase(FlowDbFileOpt);

    if (Locations.empty()) {
      errs() << "[df-coverage] No intermediate locations to instrument.\n";
      return PreservedAnalyses::all();
    }

    LLVMContext &Ctx = M.getContext();

    // Declare coverage hit function: void df_coverage_hit(uint32_t loc_id)
    FunctionCallee CoverageHitFn = M.getOrInsertFunction(
        "df_coverage_hit", FunctionType::get(Type::getVoidTy(Ctx),
                                             {Type::getInt32Ty(Ctx)}, false));
    Function *CoverageHitFunc = cast<Function>(CoverageHitFn.getCallee());

    // Find maximum location ID to size the coverage map
    uint32_t MaxID = 0;
    for (const auto &Loc : Locations) {
      if (Loc.id > MaxID)
        MaxID = Loc.id;
    }

    // Declare global coverage map size variable
    GlobalVariable *MapSizeVar = M.getGlobalVariable("__df_coverage_map_size");
    if (!MapSizeVar) {
      MapSizeVar = new GlobalVariable(
          M, Type::getInt32Ty(Ctx), true, GlobalValue::ExternalLinkage,
          ConstantInt::get(Type::getInt32Ty(Ctx), MaxID + 1),
          "__df_coverage_map_size");
    }

    errs() << "[df-coverage] Coverage map size: " << (MaxID + 1) << "\n";

    // Instrument each location
    unsigned InstrumentedCount = 0;

    // Track which locations have been instrumented to avoid duplicates
    std::set<uint32_t> InstrumentedLocations;

    for (Function &F : M) {
      if (F.isDeclaration())
        continue;

      for (Instruction &I : instructions(F)) {
        DebugLoc DL = I.getDebugLoc();
        if (!DL)
          continue;

        // Check if this instruction matches any intermediate location
        for (const auto &Loc : Locations) {
          // Skip if we've already instrumented this location
          if (InstrumentedLocations.count(Loc.id))
            continue;

          if (matchesLocation(DL, Loc)) {
            // Insert coverage hit call BEFORE this instruction
            IRBuilder<> B(&I);
            Value *LocID = ConstantInt::get(Type::getInt32Ty(Ctx), Loc.id);
            B.CreateCall(CoverageHitFunc, {LocID});

            errs() << "[df-coverage] Instrumented location ID=" << Loc.id
                   << " at " << Loc.filePath << ":" << Loc.line << ":"
                   << Loc.colStart << "-" << Loc.colEnd << "\n";
            errs() << "  Instruction: " << I << "\n";

            InstrumentedCount++;
            InstrumentedLocations.insert(Loc.id);
            break; // Only instrument once per instruction
          }
        }
      }
    }

    errs() << "[df-coverage] Total instrumented: " << InstrumentedCount
           << " locations\n";

    return InstrumentedCount > 0 ? PreservedAnalyses::none()
                                 : PreservedAnalyses::all();
  }
};

} // namespace

// === Registration boilerplate ===
llvm::PassPluginLibraryInfo getDataFlowCoveragePassPluginInfo() {
  return {LLVM_PLUGIN_API_VERSION, "DataFlowCoveragePass", LLVM_VERSION_STRING,
          [](PassBuilder &PB) {
            errs() << "=== DataFlowCoveragePass PLUGIN LOADED ===\n";
            PB.registerPipelineParsingCallback(
                [](StringRef Name, ModulePassManager &MPM,
                   ArrayRef<PassBuilder::PipelineElement>) {
                  errs() << "[DataFlowCoveragePass] Pipeline parsing callback "
                            "called with Name: "
                         << Name << "\n";
                  if (Name == "df-coverage") {
                    errs() << "[DataFlowCoveragePass] Registering pass!\n";
                    MPM.addPass(DataFlowCoveragePass());
                    return true;
                  }
                  return false;
                });
          }};
}

extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
llvmGetPassPluginInfo() {
  return getDataFlowCoveragePassPluginInfo();
}
